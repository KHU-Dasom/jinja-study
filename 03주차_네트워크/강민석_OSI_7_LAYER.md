# OSI 7 Layer, TCP/IP 4 Layer

- OSI 7계층, TCP/IP 4계층은 복잡한 네트워크를 단계별로 나누어 이해하기 쉽도록 도와주게 한다.

## 비교

과거에 통신에 대한 규약이 표준화되어 있지 않았고 벤더사마다 별도로 개발해서 호환되지 않은 시스템, 애플리케이션이 많았다.

이를 하나의 규약으로 통합하려는 노력이 현재의 OSI 7계층인것이다.

7계층이라 네트워크 동작을 나누어 이해하고 개발하는데 많은 도움을 주어서 레퍼런스용으로 많이 쓰이는데, 현재는 대부분의 프로토콜이 TCP/IP 프로토콜 스택 기반으로 되어 있다.

각각의 장단점이 있고, 구글링을 해본결과. 

TCP/IP가 **먼저** 사용되어서 라는 내용보다는

1. 진화: OSI는 문서화되어 각 기능이 명시된 논리적 모델이고, TCP/IP는 프로토콜로 구현되고 문서화되었다. 그렇기에 OSI는 이론적으로, TCP/IP는 실용적으로 진화를 한 것이다. 그렇기에 실질적으로 네트워크 모델을 구현하려면 TCP/IP모델을 사용해야한다.
2. 목표: OSI의 목표는 연결 절차, 계층화 구조, 서비스, 인터페이스 등 표준 모델을 고안하는데에 있고, TCP/IP는 신뢰할 수 있는 엔드포인트들끼리의 통신을 구성하는데에 있다는 것. 따라서 일반적이고 표준적인 모델이 필요하면 OSI, 네트워크를 통해 신뢰성과 보안이 필요한 경우 TCP/IP 모델을 선택하는게 좋다.
3. 호환성: OSI가 일반적인 모델이라 다양한 유형의 네트워크에서 사용이 가능한데, TCP/IP는 프로토콜에 의존하다보니 현재의 아키텍처에 호환이 된다. 그렇기에 다른 아키텍처에 호환이되지 않을 수 있다는 점이 있다. 범용성의 차이가 있다는 것.
4. 문서화: OSI가 일반적이라 TCP보다는 문서화(각 계층의 사양과 기능)이 잘 명시되어 있다.
5. 설정: 마찬가지로 표준적인 OSI가 설정 및 구성이 쉽다. TCP/IP는 특정 도메인과만 호환되기에 좀 더 복잡하다.

요약하자면 OSI는 보편적이여서 다른 이들에게 설명하기도 쉽다. TCP/IP는 프로토콜에 의존적이라서 구성환경이 각각 네트워크마다 다르므로 다른이들에게 설명하기 어렵다는 것이다. 자체적으로 프로토콜을 구현해서 집어넣을수도 있다는 것이다.


## OSI 7계층

```text
-- Layer --                                 데이터(PDU)

애플리케이션(Application)                      Data
프레제테이션(Presentation), 표현               Data
세션(Session)                                 Data
트랜스포트(Transport), 전송                    Segments
네트워크(Network)                             Packets
데이터링크(Data Link)                         Frames
피지컬(Physical), 물리                        Bits
```

- 1 ~ 4계층: 데이터 플로 계층/하위 계층
- 5 ~ 7계층: 애플리케이션 계층/상위 계층

- 데이터 플로계층에서는 **데이터를 상대방에게 잘 전달하는 역할을 가지고 있는 것들**
- 애플리케이션 계층에서는 **개발자들이 데이터를 표현하는데에 역할을 갖고 있는것들**

그렇기에 네트워크 개발자는 상향식(Bottom-up)으로 1계층 -> 2계층 -> 3계층.. 으로 바라보고, 애플리케이션 개발자들은 하향식(Top-Down) 7계층 -> 6계층 -> 5계층 ... 으로 바라본다.

## TCP/IP 4계층

![image](https://user-images.githubusercontent.com/30401054/204135540-81411e64-126b-4417-a65a-b52f31154d77.png)

잘보면 네트워크 개발자가 고려해야할 1 ~ 4계층과 애플리케이션 개발자가 고려해야할 5 ~ 7계층의 구분이 더 확연히 드러나있다.

## 1계층(피지컬 계층)

우리는 네트워크를 통해서 JSON  데이터를 받던 헤더에 200 OK를 받던 이 모든것들은 우리가 알아볼 수 있는 글로 변환된 것이고 컴퓨터끼리 통신할때에는 컴퓨터가 알아볼 수 있는 2진수로 이루어진 전기신호로 대화를 했을것이다. 그렇기에 물리적 통신에 목표를 둔 1계층은 전기신호를 나타내는 `Bits`로 대화를 하며 주소의 개념이 없어서 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기신호를 보낸다.

- 주요장비로는 허브, 리피터, 케이블, 커넥터, 트랜시버, 탭이 있다.

### 케이블, 커넥터, 트랜시버

![image](https://user-images.githubusercontent.com/30401054/204136258-614691a8-4d14-47f4-91a0-686fd889a96b.png)

케이블과 커넥터의 사진인데, 그 종류로는 트위스티드(Twisted), 동축(Coaxial), 광(Fiber-optic)케이블이 있다.

케이블을 연결해야하는 거리나 속도에 따라 나뉘고 용도에 맞게 사용하면 된다. 여러 표준이 있으며, 해석하는 방법이 있다.

![image](https://user-images.githubusercontent.com/30401054/204136401-734274ad-c14f-4931-b3a1-481fdb3011a0.png)

이는 기가비트 이더넷 및 10기가비트 이더넷 표준이며, 이 외에도 여러 표준이 있다.

```text
ex)   1000    BASE   -T
     속도,    채널,  케이블 타입
```

를 예시로 들면 1000은 1000Mbps로 1기가를 뜻하고, BASE는 단일 채널이라는 뜻이며 여기에는 안나와 있는 Broad는 다채널 통신을 의미한다. 그리고 마지막에 T는 (Twisted)라는 트위스티드 페어 케이블을 나타낸다. 마지막 케이블 종류에 따라 그에 맞춘 광신호, 트랜시버의 종류가 달라진다.

**트랜시버**는 외부 여러 신호를 컴퓨터가 알 수 있는 전기신호로 변환해주는 수신부와 전기 신호를 외부 신호로 변환시키는 송신부가 있는데, 이를 합쳐(**Trans**mitter + Re**cevier**) 트랜시버라 부른다.

옛날에는  다양한 이더넷 표준과 케이블을 만족하기 위해서 네트워크 장비나 NIC(네트워크 인터페이스 카드)를 별도로 구매해야 했는데, 이러한 불편함을 해소하기 위해 서로 다른 다양한 네트워크 표준을 혼용해 사용할 수 있도록 트랜시버를 사용하게 되었다.

트랜시버가 없었다면 케이블의 길이나 속도마다 다른 네트워크 장비나 NIC를 구매해야 했는데, 트랜시버를 통해 통신 길이나 속도를 조절하여 불편한 점을 해소할 수 있도록 한다.

트위스티드 페어의 경우 별도의 트랜시버가 없는 경우가 많지만, 광 케이블은 다양한 속도와 거리를 지원해야 하므로 트랜시버를 따로 분리하는 경우가 많다.

![image](https://user-images.githubusercontent.com/30401054/204137111-d4749ec1-ff2f-4828-b130-dcc577942c02.png)
> 광 트랜시버

### 허브

![image](https://user-images.githubusercontent.com/30401054/204139746-fe623d5c-204c-4b73-b53f-a3d4dfb33848.png)
> 허브

허브의 역할은 거리가 멀어질수록 줄어드는 전기 신호를 재생성하고, 여러대의 장비를 연결할 목적으로 사용된다.

위에서 주소의 개념이 없어서 모든 포트에다가 전기신호를 보낸다 했는데, 허브가 그 역할을 수행한다.

이런한 점 때문에 전체 네트워크 성능이 줄어들고 패킷이 무한 순환해 네트워크 전체를 마비시키는 경우가 있어서 현재는 거의 사용되고 있지는 않다.

### 리피터

근거리 통신망을 확장하거나 서로 연결하는데 주로 사용된다.

주 역할은 **신호를 증폭하여** 다음 구간으로 재전송하는 장치. 즉, 신호 감쇠현상을 대비하여 사용한다.

### 탭

패킷을 모니터링하는 장비이다. 트래픽을 복사해 그 복사본만 따로 확인하여 모니터링한다. 이와 반대로 회선 안에 장비가 들어가 있는 인라인(In-Line Mode)가 있는데 이는 회선에 영향을 주는 반면, 탭은 미러링(Mirroring Mode)로 회선에 영향을 주지 않는다는 장점이 있다. 

![image](https://user-images.githubusercontent.com/30401054/204137582-9dc480db-1e8a-436f-ad19-8eabe80d580b.png)
> 탭

## 2계층(데이터 링크 계층)

- 1계층에서 받은 전기 신호를 우리가 알아볼 수 있는 데이터 형태로 처리하는 곳이다.
- 1계층의 목표가 전기신호를 정확하게 전달하는 것이였다면 주소 정보를 정의하고 정확한 주소로 통신이 되도록 하는데에 초점이 맞춰져 있다.
- 2계층에서는 출발지와 목적지 주소를 확인하고 내게 보낸 것이 맞는지, 내가 처리해야 하는지에 대해 검사한 뒤 데이터 처리를 수행한다.
- 여기서는 **MAC 주소**라는 개념이 등장한다. 이를 통해 NIC와 스위치가 주소를 이해하고 통신해야할 포트를 지정해 내보내는 능력을 지닐 수 있다.

**NIC**는 고유 MAC 주소가 있는데, 입력되는 전기 신호를 데이터 형태로 만들고 데이터에서 도착지 MAC주소를 확인 후 내 것이 맞지 않다면 버려버리고 맞다면 상위 계층에서 처리할 수 있도록 메모리에 적재한다.

- NIC는 전기적 신호를 데이터 신호 형태로 또는 데이터 신호 형태를 전기적 신호로 변환하는데 이를 **직렬화**라고 한다.

![image](https://user-images.githubusercontent.com/30401054/204138918-7185de61-c7ae-499d-b9d4-31a8cf3544b4.png)
> NIC 네트워크 인터페이스 카드

**스위치**는 허브와 동일하게 여러 장비를 연결하고 통신을 중재하는 역할을 담당한다.

내부동작은 다르지만 여러 장비를 연결하고 케이블을 한곳으로 모아주는 역할은 같으므로 이를 '허브'라고 공통적으로 사용한다.

스위치는 허브의 역할과 통신을 중재하는 역할을 담당하여 **스위칭 허브**라고도 불린다.

허브와 달리 MAC주소를 이해하여 연결된 포트로만 전기 신호를 보낸다.

네트워크 전체에 불필요한 처리가 감소하면서 이더넷 기반 네트워크가 급장하는 계기가 되었다.

![image](https://user-images.githubusercontent.com/30401054/204139550-9fd1f705-cc0a-4640-adcf-4d59914e6eae.png)  
![image](https://user-images.githubusercontent.com/30401054/204139569-6fbf772c-c704-45ee-89cf-ab2a1ee42421.png)
> MAC주소와 스위치 개념도

목적지가 없는경우, MacTable에 존재하는경우, 목적지가 출발지와 같은 포트에 존재하는 경우 알고리즘이 다른데,

좀 더 자세한 내용은 <https://bannavi.tistory.com/147>를 읽어보는것을 추천한다.

![image](https://user-images.githubusercontent.com/30401054/204137134-fb356e60-03b5-4ede-bccb-cf138a20e4ee.png)
> 스위치 허브

## 3계층 네트워크 계층

2계층의 MAC주소는 물리적 주소라면 네트워크 계층에는 IP주소라는 논리적 주소가 있다.

MAC 주소와 달리 IP 주소는 사용자가 환경에 맞게 변경해 사용할 수 있다. 
NIC에는 주소가 자체적으로 있다했는데, 그게 MAC 주소이고 마음대로 바꿀 수 없다. 

MAC주소와 IP 주소는 아무런 연관관계가 없는데, 상대방의 MAC 주소를 알아내기 위해서 사용하는 프로토콜이 **ARP(Address Resoulution Protocol)**이다.

### ARP

3계층에서 쓰이는 라우터 장비는 3계층에서 정의한 IP주소를 사용해 최적의 경로를 찾아주고 해당 경로로 패킷을 전송하는 역할을 한다.

![image](https://user-images.githubusercontent.com/30401054/204142217-0e2247fd-bacc-4ac6-9c56-78ccd36d9175.png)
> ARP 프로토콜 필드(헤더 + 데이터)

호스트에서 처음 통신을 시도하면 패킷을 바로 **캡슐화**할 수 없다. 출발지와 목적지 IP 주소는 미리 알고 있어 이를 캡슐화하는데 문제가 없지만 MAC 주소를 알 수 없어서 2계층 캡슐화가 불가능한 것이다. 상대방의 MAC 주소를 알아내려면 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방의 MAC 주소를 질의해야 한다.

ARP브로드캐스트를 받은 목적지들은 자신의 MAC주소를 응답하고, 출발지 목적지 둘다 상대방에 대한 MAC주소를 학습하고 이후 패킷이 캡슐화되어 상대방에게 전달될 수 있다.

![image](https://user-images.githubusercontent.com/30401054/204142418-35c40e86-77b6-4e36-92ee-6ea2460e8944.png)

```bash
arp -a
```

명령어를 통해 ARP 테이블 정보를 확인할 수 있고, ARP 프로토콜을 통해 IP주소와 MAC 주소를 매핑하면 "유형" 필드에 '
'동적'으로 표기된다.

- 패킷을 보낼때마다 ARP브로드캐스트를 진행하면 네트워크 효율성이 크게 저하되므로 메모리에 이 정보를 저장해두고 재사용한다.

- IP주소 특성상 바뀔 수 있으므로 일정 시간 동안 통신이 없으면 테이블은 삭제가 된다.

### ARP 동작방식

```text
출발지 MAC    | 목적지 MAC  | 출발지 IP | 목적지 IP
AA               -             1.1.1.1    1.1.1.2

-------------------------------------------------

서버A(1.1.1.1)    -------->  서버B(1.1.1.2)
MAC(AA)                      MAC(BB)
```

- 이러한 예제가 있다고 치면, 서버A에서 ping을 보낼때 3계층의 IP주소 까지는 캡슐화하지만 상대방의 MAC 주소를 모르기에 2계층은 캡슐화가 불가능하다.

- 상대방의 MAC 주소를 알아내기 위해 ARP 요청을 네트워크에 브로드캐스트 한다.
- ARP 요청을 보내기 위해 패킷을 다음과 같이 구성한다.

```text
--ARP 패킷
출발지 MAC    | 목적지 MAC  | 전송자 MAC | 전송자 IP | 대상자 MAC | 목적지 IP
AA             브로드캐스트      AA        1.1.1.1        00       1.1.1.2

-------------------------------------------------

서버A(1.1.1.1)    -------->  서버B(1.1.1.2)
MAC(AA)                      MAC(BB)
```

> 참고용 브로드캐스트는 (FF-FF-FF-FF-FF-FF), 대상자 MAC은 (00-00-00-00-00-00)으로 채움.

이를 네트워크에 뿌린다.

- 모든 단말이 요청을 받았을때 자기의 IP면 응답하고 아니면 ARP패킷을 폐기한다.
- 응답할때 송신자와 대상자의 위치가 바뀐다.
- 이때 B서버기준 패킷을 받았을때 보낸곳의 IP와 MAC주소를 알고 있으므로 자신의 ARP 캐시 테이블에 정보를 담아 놓는다.
- 그리고 보낼때는 출발지와 도착지의 MAC 주소가 명시되어 있는 **유니캐스트(unicast)**로 한다.

```text
--ARP 패킷 응답
출발지 MAC    | 목적지 MAC  | 전송자 MAC | 전송자 IP | 대상자 MAC | 목적지 IP
BB                AA             BB        1.1.1.2        AA       1.1.1.1

-------------------------------------------------

서버A(1.1.1.1)    <--------  서버B(1.1.1.2)
MAC(AA)                      MAC(BB)

------------------------------------------------
서버 A 캐시테이블
---------------
인터넷 주소 | 물리 주소 | 유형
1.1.1.2         BB       동적
```

- 서버 A는 ARP 응답을 받고 자신의 ARP 캐시 테이블을 갱신하고 데이터를 캡슐화하여 ping을 보낸다.

```text
--ping 요청
출발지 MAC    | 목적지 MAC  | 출발지 IP | 목적지 IP
AA               BB             1.1.1.1    1.1.1.2

-------------------------------------------------

서버A(1.1.1.1)    -------->  서버B(1.1.1.2)
MAC(AA)                      MAC(BB)
```

이 외에도 GARP, RARP같은 프로토콜이 있다.

## 4계층(트랜스포트 계층)

4계층은 1, 2, 3계층과는 다른 역할을 수행한다.

1, 2, 3계층은 신호와 데이터를 올바른 위치에 보내고 실제 신호를 잘 만들어 보내는 데 집중하였다.

4계층은 해당 데이터들이 실제로 잘 보내졌는지 확인하는 역할을 담당한다.

예를들어, 패킷이 도중에 유실되거나 순서가 바뀌는 등 이러한 문제를 바로 잡아주는 역할을 수행한다.

4계층에서 동작하는 장비로는 로드 밸런서와 방화벽이 있다. 부하를 분산시키거나 보안 정책을 수립해 패킷을 통과하거나 차단하는 기능을 수행한다.

또한 여기에 포함되어 있는 TCP, UDP 프로토콜에 대해서는 [준식이 글](https://github.com/KHU-Dasom/jinja-study/blob/main/3%EC%A3%BC%EC%B0%A8_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/%ED%99%8D%EC%A4%80%EC%8B%9D_TCP.md)을 통해 볼 수 있다.

## 5계층(세션 계층)

5계층의 역할은 양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고 연결이 안정적으로 유지되도록 관리하고 작업 완료 후 연결을 끊는 역할을 한다. 예를 들어 통신이 끊어진 부분부터 다시 이어서 데이터를 전송받는 기능을 생각하면 된다.

## 6계층(프레제테이션 계층)

데이터 형식을 변환하거나, MIME 인코딩, 암호화와 복호화, 데이터 압축을 수행한다.

예를 들어 EBCDIC(확장 이진화 십진법 교환 부호)로 인코딩된 문서 파일을 ASCII로 인코딩 된 파일로 바꿔주거나 해당 데이터가 TEXT인지, 그림인지 등을 식별한다.

![image](https://user-images.githubusercontent.com/30401054/204143975-e2fdb7db-97bd-437b-9daf-7a2fc1e5ab3d.png)

## 7계층(애플리케이션 계층)

네트워크 소프트웨어의 UI부분이나 사용자 입.출력 부분을 정의하는 것이 애플리케이션 계층의 역할  
EX) chome, firefox등 사용자에게 보여지는 UI 이를 통해 사용자는 네트워크 통신을 할 수 있다.

그리고 대표적으로 FTP, SMTP, HTTP, TELNET 등의 프로토콜이 있다.

## 인캡슐레이션과 디캡슐레이션

![image](https://user-images.githubusercontent.com/30401054/204143743-9debf35a-772e-47b9-9cc4-8edc89cb24f0.png)

데이터를 보내는 과정을 **인캡슐레이션** 데이터를 받는 과정을 **디캡슐레이션**이라고 한다.





## Reference

- <https://afteracademy.com/blog/which-model-is-better-osi-or-tcpip/> - TCP/IP가 더 쓰이는 이유.
- <https://bannavi.tistory.com/147> MAC주소에 대한 동작방식 읽기 추천.